#include <stdio.h>
/*
int main(void)
{

	<함수에 대한 고급 이론>
	함수의 이름 > 배열의 이름처럼 '주소 상수'에 부여한 식별자
	포인터 변수(함수 포인터)에 담을 수 있는 정보

	배열 - > 자료
	ㄴ> 식별시 주소로 한다. *주소 상수
	자료형
	1. 정수형
	2. 실수형
	3. 유도형 : 배열 

	 이것말고 '함수형'이라는 것이 있다.
	 ㅇ        ㅇ        ㅇ()   >형태
	 반환형식  호출규칙	 이름(주소)
	 
	 
	 이 함수라는 것은 '기계어'로 번역이 된다.
	 어떠한 메모리에 저장되어 있다
	 이런 메모리의 특징 = R-X가능 W불가능
	 >>연산하는 코드에 대한 해석이 변화가 일어나기 때문



	 < 성능 향상 >
	 - 함수 호출시에는 비용이 든다 (CPU연산 + 메모리 사용) 
	 - 함수 호출 자체가 연산인데다 스택을 사용해야 하기도 해서 성능이 떨어진다. 
	 - 매크로는 매개변수의 자료형이 없다 >> 치명적인 단점
	   그로인해, __inline함수가 탄생함.

	 */



/*

<컴파일러 최적화>

ex)

int Add(int a, int b)
{
	int nResult = 0;
	nResult = a+b;
	return nResult;
}

int main(void)
{
	int nResult = 0;
	nResult = Add(3,4);
	printf("%d\n", nResult);
	return 0;
}

	=================위 코드를====================
	== 릴리즈 모드로 실행 시 '최적화'를 거쳐 연산함==
	==============================================
	-  어셈블리어를 봤을때 > push 7
	- Add()함수는 아예 번역조차 하지 않았으며 3과 4를 더한 결과가 7임을 인식한 컴파일러는
	   굳이 덧셈 연산을 하지 않고 바로 인수 7을 printf에 호출함
	- 즉, Printf("%d", 7); 이라고 한줄만 작성한 코드처럼 번역됨

	**이와같이 최적화 할 수 있었던 이유**
	1. Add()함수의 매개변수를 '상수'로 기술했기 때문
	2. 변수 = 아직 정해지지 않은 문자 > 변할 수 있는 속성을 가진다
	(컴파일러는 이것을 알고있다)
	따라서 , 아직 값이 확정되지 않은 변수에 대한 연산은 그 변수에 대해 의존적일 수 밖에 없다.

	


	<만약, Add(x,y)와 같이 변수로 바뀌어 버린다면?>

	int Add(int a, int b)
	{
		int nResult = 0;
		nResult = a+b;
		return nResult;
	}

	int main(void)
	{
		int nResult = 0,x,y;
		scanf_s("%d %d", &x, &y);
		nResult = Add(x,y);
		printf("%d\n", nResult);
		return 0;
	}

	- 릴리즈 모드로 실행시

	1.Add()함수는 번역 하지 않는다.
	> 그래서 인지 add edx, dword ptr[y]라는 어셈블리어 코드가 존재함을 확인할 수 있다. 
	( 어셈블리어 찍어보면 나옴, 변수일 때) 
	> 즉 사용자가 입력한 정보를 덧셈만 해서 결과를 계산하도록 번역된 것.
	2. 따라서 결과적으로는 함수를 호출한 것과 마찬가지다. 

	*/


/*

	<최적화>
	1. 컴파일러가 한다
	2. 돕는코드 - 'Const'같이 상수화된 코드 사용해주면 좋다.




	<__inline함수>
	
	- 장점 : 매크로와 같다.
	
	- __inline함수의 제약 : 애매하다 > 컴파일러가 코드를 보고 판단함
	( 컴파일러가 보고 되는애는 최적화를 하고 안되는 애는 안함 )

	- 매크로의 심각한 오류
	 > 실제로는 함수가 아니면서 함수인척 한다는 사실
	 1. 매개변수의 자료형
	 2. 괄호
	 3. 지역변수
	 4. 제어문 문제 등
	 다양한 문법접 단점을 inline함수를 통해 매크로의 단점을 극복. 
	 
	>
	
	*/
	
	
	/*
		<함수 호출 규칙>
		 - 함수 호출 규칙 (calling convention)은 호출자 함수가 피 호출자 함수를 호출하는 과정에서
		 매개변수를 전달하는 순서 및 매개변수가 사용한 메모리 관리 방법등에 관한 규칙

		 대표적으로 3가지가 있다.
		 1. __cdecl
		 2. __stdcall
		 3. __fastcall
		- 위 세가지 정도가 있는데 C언어의 표준에서 정의하는 것은 아니다.
		- C/C++ 컴파일러의 기본 함수 호출 규칙 = __cdecl


		자동변수 auto와 같이 __cdecl은 생략가능 > 즉 안쓰면 알아서 __cdecl이다.
		- > 보통은 '자동변수'처럼 '스택'을 사용한다.


		stack = 선형 자료구조
		김치냉장고 
		먼저 들어간놈이 나중에 나옴
		들어갔다 나오면서 순서가 바뀜


		<함수call>
		- main()함수에서 TestFunc(int nParam)를 call

	    ----------|-------
		TestFunc()| nParam           --------------> 1. 현재 스택의 위치
	    ----------|-------
				  | 20 = b의 매개변수 --------------> 2. 반환 후 스택의 위치
		----------|-------
		main()	  | 10 = a의 매개변수
		----------|-------

		- 반환하게 되면 스택이 내려온다.
		- nParam이 사라진것 처럼 된다.
		- 자동변수이다.
		- 메모리 할당 대체를 자유롭게 한다.



		<세 함수의 호출 규칙>
		--------------------------------------------------------------------------
		|    호출 규칙    |     매개 변수 스택 정리      |     매개 변수 메모리      |
			__cdecl				Caller가 함						Stack

			__stdcall			Callee가 함						Stack

			__fastcall			Callee가 함					Stack + Register
		---------------------------------------------------------------------------


		- 피 호출자 함수가 반환하면서 자기가 교통 정리를 한다 = c/c++  __cdecl


		<__cdecl 호출 규칙>

		- 매개 변수를 오른쪽부터 push한다
												
		ex) TestFunc(int a, int b, int c)는 아래 그림과 같다.

				  |----
				  | a
				  |----
				  |	b
		----------|----
		TestFunc()| c
		----------|----   - 오른쪽부터 스택을 먼저 쌓는다.

		
		
		< 왜 일까 ? >
		1. a, b가 있다.
		
		2. push한다. 
		|_b_|
		|_a_|

		3. 꺼낸다. 
		|___| > b
		|_a_|  

		- b, a 순서가 바뀐다.
		- stack = 선형 자료구조
	

	
		<Main에서 GetMax를 Call>

				  |----
				  | a
				  |----
				  |	b
		----------|----
		  GetMax()| c
		----------|----  
		  main()  | 10 = nResult
		---------------
	    
		- 매개변수가 스택에 먼저 표시된다.
		- 그럼 __cdecl type인 경우 >> 누가 stack을 정리하나? >> Caller가 한다.
		
		(stack을 정리한다는 건 어떤의미?)
		> a지점을 스택의 Top으로 지정했다가 반환되면서 스택의 Top지점이 아래로 흘러내린다. 
		> Top지점이라는 것은 어디에 있냐 = ESP (확장 스택 포인터) ESP register에 들어있다.


		- 스택 정리를 하면 쌓였던 스택메모리가 자동으로 싹 날아간다. ( 자동변수 ) 
	
	
	
	
		<GetMax(1,2,3)>
		
		[어셈블리어]
		
		push  3
		push  2
		push  1
		call  _GetMax()
		add   esp, 0ch >> 이부분이 중요

		esp = stack pointer의 값이 증가 했다.
		 > 스택은 기어내려갔다 얼마만큼? 0x0c만큼  > 0c = 12
		 왜 12?  > 12byte (int형 3개만큼) GetMax()매개변수가 int형 3개 이기 때문에.


		
		
		
		<만약, __cdecl이 아닌 __stdcall이 있었다면>
		 - 함수를 call 하긴 한다. 
		 
		 [어셈블리어]

		 call  _GetMax@/2
		 (add  esp불라불라가 없다)
		 이 뜻은 > Caller에서 stack 정리를 하는 것이 아니라 Callee함수 GetMax()내부에서 한다는 뜻!





		 <fastcall>

		 - stdcall과 fastcall은 비슷하지만 차이가 있다.
		 1. 매개변수를 stack을 이용해 복사하는것이 아니라
		 (아래 예시를 보겠다)

		 int __fastcall GetMax(int a, int b, int c)
		 {
			int nMax = a;
			if(nMax < b)  nMax = b;
			if(nMax < c)  nMax = c;
			return nMax;
		  }

		  [어셈블리어]

		  GetMax(1, 2, 3)
		  
		  push	3
		  mov	edx, 1    >> b
		  mov	ecx, 2    >> a   - 전달 과정에서 레지스터에 넣어서 메모리 카피가 1번 줄어든다.
		  call	@GetMax@\2



		  <stdcall VS fastcall>

		  1. __stdcall
		  - stack메모리 즉, RAM에서 다시 또다른 RAM의 또 다른 영역으로 copy가 일어난다.
		  RAM > RAM

		  2. __fastcall
		   - Register에서 stack memory RAM으로 Copy가 된다.
		   그것도 '1번'만 > 그래서 성능이 향상(속도증가)




		   <그렇다면 언제  fastcall을 사용할까?>

		   - 컴파일에 의해 알아서 좋은것으로 골라 사용되기 때문에 크게 사용되지 않는다.
		   (컴파일에서 알아서 적용되기 때문에)

		   * 참고로 윈도우 API가 __stdcall(standardcall)를 사용한다.
		   
	*/



























